<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pappus's Theorem - Lines & Arcs (Compact Calc)</title>

    <style>
        /* Base styles */
        html, body { height: 100%; margin: 0; overflow: hidden; font-family: sans-serif; background-color: #f0f0f0; }
        #container { display: flex; flex-direction: column; width: 100vw; height: 100vh; }
        #ui-controls { width: 100%; max-height: 45vh; min-height: 180px; padding: 10px 15px; background-color: #e9e9e9; overflow-y: auto; box-sizing: border-box; border-bottom: 2px solid #ccc; display: flex; flex-wrap: wrap; justify-content: space-around; align-items: flex-start; gap: 10px 15px; }
        #visualization-container { flex-grow: 1; position: relative; min-height: 200px; background-color: #cccccc; }
        #visualizationCanvas { display: block; width: 100%; height: 100%; }

        /* Headings & Sections */
        #ui-controls h1, #ui-controls h2 { margin-top: 0; margin-bottom: 8px; border-bottom: 1px solid #ccc; padding-bottom: 4px; color: #333; width: 100%; text-align: center; font-size: 1.2em; }
        #ui-controls h2 { font-size: 1.0em; text-align: left; margin-top: 5px; }
        #ui-controls > p { width: 100%; text-align: center; margin: 0 0 10px 0; font-size: 0.9em; }
        .ui-section { margin-bottom: 0; padding: 10px; background-color: #fff; border: 1px solid #ddd; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); flex: 1 1 300px; min-width: 280px; }
        #instructions { flex-basis: 100%; background-color: #f0f8ff; border-color: #cce5ff; }

        /* Add Segment Controls */
        #add-controls { display: flex; align-items: center; gap: 15px; margin-bottom: 10px; flex-wrap: wrap; width: 100%; padding: 5px; background: #ddd; border-radius: 4px;}
        #add-controls label { margin-bottom: 0; font-weight: bold;}
        #add-controls select { padding: 5px; border-radius: 3px; border: 1px solid #ccc; }
        #addSegmentBtn { margin-bottom: 0; }


        /* Buttons */
        button { padding: 6px 12px; margin-bottom: 8px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; transition: background-color 0.2s ease; font-size: 0.9em; }
        button:hover { background-color: #0056b3; }
        .removeSegmentBtn { background-color: #dc3545; float: right; margin-left: 10px; padding: 3px 6px; font-size: 0.75em; }
        .removeSegmentBtn:hover { background-color: #c82333; }

        /* Labels and Inputs */
        label { margin-right: 5px; display: inline-block; margin-bottom: 4px; font-size: 0.9em;}
        input[type="number"] { width: 55px; padding: 4px 3px; margin: 1px 2px 1px 0; border: 1px solid #ccc; border-radius: 3px; box-sizing: border-box; text-align: right; font-size: 0.9em; }
        input[type="range"] { width: 150px; vertical-align: middle; }
        #angleValue { display: inline-block; width: 30px; text-align: right; font-weight: bold; margin-left: 4px; font-size: 0.9em;}


        /* Calculations Section - Compact */
        #calculations-section {
             padding: 8px 10px; /* Reduced padding */
         }
         #calculations-section h2 {
             margin-bottom: 5px; /* Reduced margin */
         }
        .calc-row {
            display: flex;
            justify-content: space-between; /* Space items in a row */
            align-items: center;
            margin-bottom: 3px; /* Reduced space between rows */
            gap: 5px; /* Space between items if they wrap */
            flex-wrap: wrap; /* Allow wrapping if needed */
        }
        .calc-item {
            display: flex; /* Align label and value */
            align-items: center;
            white-space: nowrap; /* Prevent label/value breaking */
            margin-right: 5px; /* Space between items */
        }
         .calc-item-wide { /* For the centroid coordinates */
             flex-grow: 2; /* Allow centroid to take more space */
         }

        .calc-label-compact { /* Style for compact labels */
            font-size: 0.85em;
            color: #333;
            margin-right: 3px; /* Space between label and value */
        }

        #calculations-section span:not(.calc-label-compact) { /* Style for values */
            font-weight: bold;
            background-color: #eef;
            padding: 1px 4px; /* Slightly adjusted padding */
            border-radius: 3px;
            display: inline-block;
            min-width: 40px; /* Reduced min-width */
            text-align: right;
            font-size: 0.9em; /* Consistent font size */
            line-height: 1.2;
        }
        /* Specific Value Styling */
        #totalLength { color: #0000ff; background-color: #e0e0ff; }
        #centroidCoords { min-width: 120px; text-align: left; background-color: #eee; color: #333;} /* Reduced min-width */
        #centroidDistanceR, #centroidDistanceD, #surfaceArea { color: #0056b3; background-color: #eef; }
        #partialSurfaceArea, #calculatedDistanceR { color: #dc3545; background-color: #ffe0e0; }
        .realtime-calc { margin-top: 5px; /* Reduced space before real-time */ }


        /* Segment Input Area */
        .segment-input-container { margin-bottom: 10px; padding: 8px; border: 1px dashed #ccc; border-radius: 3px; background-color: #fdfdfd; }
        .segment-type-display { font-style: italic; font-size: 0.8em; color: #555; margin-bottom: 4px; display: block; }
        .point-input-group { display: flex; align-items: center; margin-bottom: 4px; }
        .point-input-group > span { font-weight: bold; margin-right: 5px; min-width: 45px; text-align: right; font-size: 0.9em; }
        .center-input-group { color: #337ab7; }
        .center-inputs { display: block; }
        .hidden { display: none !important; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; } input[type=number] { -moz-appearance: textfield; }

        /* Instructions */
        #instructions ul { padding-left: 18px; margin-top: 4px; margin-bottom: 4px; font-size: 0.85em; color: #333; }
        #instructions li { margin-bottom: 4px; }
        #instructions strong { color: #004085; }

        /* Settings Layout */
        #settings-section > div { margin-bottom: 8px; }
        #settings-section > div > label:first-child { font-weight: bold; margin-right: 8px; min-width: 100px; display: inline-block; }
        #settings-section > div > label > input[type="radio"] { margin-right: 2px; vertical-align: middle; }
        #settings-section label[for="revolutionSlider"] { font-weight: bold; min-width: 100px; display: inline-block; }

        /* Responsive Adjustments */
        @media (max-width: 768px) { #ui-controls { max-height: 55vh; } .ui-section { flex-basis: 45%; min-width: 250px; } #instructions { flex-basis: 95%;} }
        @media (max-width: 600px) { .ui-section { flex-basis: 95%; } #ui-controls h1 { font-size: 1.1em;} #ui-controls h2 { font-size: 0.95em;} }
        @media (max-width: 400px) { #ui-controls { padding: 5px; gap: 5px; max-height: 60vh;} .ui-section, #instructions { padding: 8px; } input[type="number"] { width: 50px; } input[type="range"] { width: 120px; } button { padding: 5px 10px; font-size: 0.85em;} .removeSegmentBtn { padding: 2px 5px; font-size: 0.7em; } .point-input-group > span { min-width: 35px;} .calc-label-compact { font-size: 0.8em; } #calculations-section span:not(.calc-label-compact) { font-size: 0.85em; min-width: 35px; padding: 1px 3px;} .calc-row { margin-bottom: 2px; } .calc-item { margin-right: 3px;} }

    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="container">
         <div id="ui-controls">
            <h1>Pappus's Theorem II</h1>
            <p>Surface Area = Total Length (L) × Centroid Path Distance (d)</p>

            <!-- Add Segment Controls -->
            <div id="add-controls">
                 <label for="segmentTypeSelector">Add:</label>
                 <select id="segmentTypeSelector">
                     <option value="line" selected>Line Segment</option>
                     <option value="arc">Circular Arc</option>
                 </select>
                 <button id="addSegmentBtn">Add Element</button>
            </div>

            <!-- Sections -->
            <div id="segments-section" class="ui-section"><h2>Elements</h2><div id="segmentsContainer"></div></div>
            <div id="settings-section" class="ui-section"><h2>Settings</h2><div><label>Axis of Rotation:</label><label><input type="radio" name="axis" value="x"> X</label><label><input type="radio" name="axis" value="y" checked> Y</label><label><input type="radio" name="axis" value="z"> Z</label></div><div><label for="revolutionSlider">Revolution Angle:</label><input type="range" id="revolutionSlider" min="0" max="360" value="360" step="1"><span id="angleValue">360</span>°</div></div>

            <!-- Compact Calculations Section -->
            <div id="calculations-section" class="ui-section">
                <h2>Calculations</h2>
                <div class="calc-row">
                    <div class="calc-item">
                        <span class="calc-label-compact">L:</span>
                        <span id="totalLength">0.000</span>
                    </div>
                     <div class="calc-item calc-item-wide">
                        <span class="calc-label-compact">C:</span>
                        <span id="centroidCoords">N/A</span>
                    </div>
                </div>
                 <div class="calc-row realtime-calc">
                     <div class="calc-item">
                        <span class="calc-label-compact">S (partial):</span>
                        <span id="partialSurfaceArea">0.000</span>
                    </div>
                     <div class="calc-item">
                        <span class="calc-label-compact">R (S/2πL):</span>
                        <span id="calculatedDistanceR">0.000</span>
                    </div>
                </div>
                <div class="calc-row">
                     <div class="calc-item">
                        <span class="calc-label-compact">R (full):</span>
                        <span id="centroidDistanceR">0.000</span>
                    </div>
                    <div class="calc-item">
                        <span class="calc-label-compact">d (2πR_full):</span>
                        <span id="centroidDistanceD">0.000</span>
                    </div>
                    <div class="calc-item">
                        <span class="calc-label-compact">Area (L*d):</span>
                        <span id="surfaceArea">0.000</span>
                    </div>
                </div>
            </div>

            <div id="instructions" class="ui-section"><p><strong>Instructions:</strong></p><ul><li>Select 'Line Segment' or 'Circular Arc' and click 'Add Element'.</li><li>For Arcs, define Start (P1), End (P2), and Center (C).</li><li>Remove elements using the 'Remove' button.</li><li>Use mouse (Left-drag: rotate, Right-drag: pan, Wheel: zoom) to view.</li><li>Select rotation axis (X, Y, or Z). Standard axes shown (X:Red, Y:Green, Z:Blue).</li><li>Adjust the slider to see partial revolution and real-time calculation updates.</li><li>Calculations apply to the entire shape (all lines and arcs combined).</li></ul></div>
        </div>
        <div id="visualization-container"><canvas id="visualizationCanvas"></canvas></div>
    </div>

    <!-- Segment Template -->
    <template id="segmentTemplate">
        <div class="segment-input-container" data-type="line">
            <button class="removeSegmentBtn">Remove</button>
            <span class="segment-type-display">Line Segment</span>
            <div class="point-input-group">
                <span>P1:</span>
                <input type="number" class="coord p1x" value="0" step="0.1" placeholder="X" title="P1 X">
                <input type="number" class="coord p1y" value="0" step="0.1" placeholder="Y" title="P1 Y">
                <input type="number" class="coord p1z" value="0" step="0.1" placeholder="Z" title="P1 Z">
            </div>
             <div class="point-input-group">
                 <span>P2:</span>
                <input type="number" class="coord p2x" value="1" step="0.1" placeholder="X" title="P2 X">
                <input type="number" class="coord p2y" value="1" step="0.1" placeholder="Y" title="P2 Y">
                <input type="number" class="coord p2z" value="0" step="0.1" placeholder="Z" title="P2 Z">
            </div>
            <div class="point-input-group center-input-group center-inputs hidden">
                 <span>Center:</span>
                <input type="number" class="coord cx" value="0.5" step="0.1" placeholder="X" title="Center X">
                <input type="number" class="coord cy" value="0.5" step="0.1" placeholder="Y" title="Center Y">
                <input type="number" class="coord cz" value="0" step="0.1" placeholder="Z" title="Center Z">
            </div>
        </div>
    </template>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let segmentsData = [];
        let segmentLines = [];
        let surfaceMeshes = [];
        let axisOfRotation = 'y';
        let revolutionAngle = 360;
        let axisHelper, centroidPathVisual;
        let axisLabels = [];
        let sharedSurfaceMaterial;
        let currentTotalLength = 0;
        let currentCentroidDistanceR = 0;
        const EPSILON = 1e-5;

        // --- Constants ---
        const SEGMENT_COLOR = 0x0000ff;
        const ARC_COLOR = 0x9900ff;
        const SURFACE_COLOR = 0xffa500;
        const CENTROID_PATH_COLOR = 0x00ff00;
        const RADIAL_SEGMENTS = 32;
        const ARC_SUBDIVISIONS = 16;
        const CENTROID_PATH_SEGMENTS = 64;
        const AXIS_LABEL_OFFSET = 6.0;
        const AXIS_LABEL_SIZE = 1.5;

        // --- DOM Elements ---
        const segmentsContainer = document.getElementById('segmentsContainer');
        const addSegmentBtn = document.getElementById('addSegmentBtn');
        const segmentTypeSelector = document.getElementById('segmentTypeSelector');
        const segmentTemplate = document.getElementById('segmentTemplate');
        const revolutionSlider = document.getElementById('revolutionSlider');
        const angleValueSpan = document.getElementById('angleValue');
        const axisRadios = document.querySelectorAll('input[name="axis"]');
        const totalLengthSpan = document.getElementById('totalLength');
        const centroidCoordsSpan = document.getElementById('centroidCoords');
        const centroidDistanceRSpan = document.getElementById('centroidDistanceR');
        const centroidDistanceDSpan = document.getElementById('centroidDistanceD');
        const surfaceAreaSpan = document.getElementById('surfaceArea');
        const partialSurfaceAreaSpan = document.getElementById('partialSurfaceArea');
        const calculatedDistanceRSpan = document.getElementById('calculatedDistanceR');

        // --- Rotation Axis Vectors ---
        const AXIS_VECTORS = { x: new THREE.Vector3(1, 0, 0), y: new THREE.Vector3(0, 1, 0), z: new THREE.Vector3(0, 0, 1) };

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xcccccc);
            const vizContainer = document.getElementById('visualization-container');
            camera = new THREE.PerspectiveCamera(60, vizContainer.clientWidth / vizContainer.clientHeight, 0.1, 1000);
            camera.position.set(6, 6, 12); camera.lookAt(0, 0, 0);
            const canvas = document.getElementById('visualizationCanvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio); renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.0; resizeRenderer();
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); scene.add(ambientLight);
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight1.position.set(5, 10, 7.5); scene.add(directionalLight1);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4); directionalLight2.position.set(-5, -5, -5); scene.add(directionalLight2);
            controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.minDistance = 1; controls.maxDistance = 100; controls.maxPolarAngle = Math.PI;

            // Load Environment Map
            const loader = new THREE.CubeTextureLoader();
            const texturePath = './textures/cube/bridge2/'; // Example path - CHANGE IF NEEDED
            const textureFiles = [ 'posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg' ];
            try { const textureCube = loader.setPath(texturePath).load( textureFiles, () => { console.log("Env map loaded."); }, undefined, (error) => { console.error(`Error loading env map from ${texturePath}:`, error); alert(`Could not load env map textures from ${texturePath}.`); }); scene.environment = textureCube; } catch (e) { console.error("Failed env map load setup:", e); alert("Error setting up env map loader."); }

            // Create Shared Surface Material
            sharedSurfaceMaterial = new THREE.MeshStandardMaterial({ color: SURFACE_COLOR, transparent: true, opacity: 0.65, side: THREE.DoubleSide, metalness: 0.2, roughness: 0.3, envMapIntensity: 1.0, refractionRatio: 0.95, });

            // Helpers & Labels
            axisHelper = new THREE.AxesHelper(5); scene.add(axisHelper); createAxisLabels();

            // Event Listeners
            addSegmentBtn.addEventListener('click', () => addSegmentUI(true)); // Ensure update on manual add
            segmentsContainer.addEventListener('input', handleSegmentInputChange);
            segmentsContainer.addEventListener('click', handleRemoveSegmentClick);
            revolutionSlider.addEventListener('input', handleRevolutionSlider);
            axisRadios.forEach(radio => radio.addEventListener('change', handleAxisChange));
            window.addEventListener('resize', resizeRenderer);

            // Initial Setup
            addSegmentUI(false); // Add default without triggering update yet
            const firstSegInputs = segmentsContainer.querySelector('.segment-input-container');
            if (firstSegInputs) { firstSegInputs.querySelector('.p1x').value = 0.5; firstSegInputs.querySelector('.p1y').value = 1; firstSegInputs.querySelector('.p2x').value = 1.5; firstSegInputs.querySelector('.p2y').value = 2; firstSegInputs.querySelector('.p2z').value = 0.5; }
            updateVisualizationAndCalculations(); // Now update
            animate();
        }

        // --- resizeRenderer ---
        function resizeRenderer() { const vizContainer = document.getElementById('visualization-container'); const width = vizContainer.clientWidth; const height = vizContainer.clientHeight; if (width === 0 || height === 0) return; renderer.setSize(width, height); camera.aspect = width / height; camera.updateProjectionMatrix(); }

        // --- UI Management ---
         function addSegmentUI(update = true) {
            const selectedType = segmentTypeSelector.value;
            const templateContent = segmentTemplate.content.cloneNode(true);
            const containerDiv = templateContent.querySelector('.segment-input-container');
            const centerInputsDiv = templateContent.querySelector('.center-inputs');
            const typeDisplaySpan = templateContent.querySelector('.segment-type-display');
            containerDiv.dataset.type = selectedType;
            if (selectedType === 'line') { typeDisplaySpan.textContent = 'Line Segment'; centerInputsDiv.classList.add('hidden'); }
            else { typeDisplaySpan.textContent = 'Circular Arc'; centerInputsDiv.classList.remove('hidden'); const p1yInput = templateContent.querySelector('.p1y'); const p2xInput = templateContent.querySelector('.p2x'); const cxInput = templateContent.querySelector('.cx'); const cyInput = templateContent.querySelector('.cy'); if(p1yInput) p1yInput.value = 2; if(p2xInput) p2xInput.value = 2; if(cxInput) cxInput.value = 1; if(cyInput) cyInput.value = 1; }
            segmentsContainer.appendChild(templateContent);
            if(update) updateVisualizationAndCalculations();
        }
        function handleSegmentInputChange(event) { if (event.target.classList.contains('coord')) { updateVisualizationAndCalculations(); } }
        function handleRemoveSegmentClick(event) { if (event.target.classList.contains('removeSegmentBtn')) { event.target.closest('.segment-input-container').remove(); updateVisualizationAndCalculations(); } }
        function handleRevolutionSlider(event) { revolutionAngle = parseFloat(event.target.value); angleValueSpan.textContent = revolutionAngle; clearSurfaceMeshes(); drawSurfaceOfRevolution_Manual_PerSegment(); updateRealTimeCalculations(); if (centroidPathVisual) { centroidPathVisual.visible = (revolutionAngle === 360); } }
        function handleAxisChange(event) { axisOfRotation = event.target.value; updateVisualizationAndCalculations(); }

        // --- Data Parsing ---
        function parseSegmentsFromUI() {
            segmentsData = [];
            const segmentDivs = segmentsContainer.querySelectorAll('.segment-input-container');
            segmentDivs.forEach((div, index) => {
                const type = div.dataset.type || 'line';
                const p1 = new THREE.Vector3( parseFloat(div.querySelector('.p1x').value) || 0, parseFloat(div.querySelector('.p1y').value) || 0, parseFloat(div.querySelector('.p1z').value) || 0 );
                const p2 = new THREE.Vector3( parseFloat(div.querySelector('.p2x').value) || 0, parseFloat(div.querySelector('.p2y').value) || 0, parseFloat(div.querySelector('.p2z').value) || 0 );
                let elementData = { type, p1, p2, length: 0, centroid: new THREE.Vector3() }; let isValid = false; div.style.borderColor = '#ccc';
                if (type === 'line') { if (p1.distanceTo(p2) > EPSILON) { elementData.length = p1.distanceTo(p2); elementData.centroid.addVectors(p1, p2).multiplyScalar(0.5); isValid = true; } else { console.warn(`Line ${index+1}: Start/end points too close.`); div.style.borderColor = 'orange'; } }
                else if (type === 'arc') {
                    const center = new THREE.Vector3( parseFloat(div.querySelector('.cx').value) || 0, parseFloat(div.querySelector('.cy').value) || 0, parseFloat(div.querySelector('.cz').value) || 0 );
                    const radius1 = center.distanceTo(p1); const radius2 = center.distanceTo(p2);
                    if (radius1 < EPSILON) { console.warn(`Arc ${index+1}: Radius zero.`); div.style.borderColor = 'orange'; }
                    else if (Math.abs(radius1 - radius2) > EPSILON * radius1) { console.warn(`Arc ${index+1}: P1/P2 not equidistant from C.`); div.style.borderColor = 'orange'; }
                    else if (p1.distanceTo(p2) < EPSILON) { console.warn(`Arc ${index+1}: P1/P2 same.`); div.style.borderColor = 'orange'; }
                    else {
                        const v1 = p1.clone().sub(center); const v2 = p2.clone().sub(center); const v1_norm = v1.clone().normalize(); const v2_norm = v2.clone().normalize();
                        elementData.radius = radius1; elementData.center = center;
                        let dot = v1_norm.dot(v2_norm); dot = Math.max(-1.0, Math.min(1.0, dot)); elementData.sweepAngle = Math.acos(dot);
                        if (elementData.sweepAngle < EPSILON) { console.warn(`Arc ${index+1}: Sweep angle too small.`); div.style.borderColor = 'orange'; }
                        else {
                            elementData.length = elementData.radius * elementData.sweepAngle;
                            elementData.normal = new THREE.Vector3().crossVectors(v1, v2);
                            if (elementData.normal.lengthSq() < EPSILON * EPSILON) { console.warn(`Arc ${index+1}: Collinear points.`); div.style.borderColor = 'red'; elementData.normal.set(0,0,1); }
                            else {
                                elementData.normal.normalize();
                                const centroidDist = (elementData.radius * 2 * Math.sin(elementData.sweepAngle / 2)) / elementData.sweepAngle;
                                const bisectorDir = v1_norm.clone().add(v2_norm).normalize(); elementData.centroid.copy(center).addScaledVector(bisectorDir, centroidDist); isValid = true;
                             } } } }
                 if(isValid) { segmentsData.push(elementData); } else { console.log(`Skipping invalid element ${index+1}`); } });
        }

        // --- Calculations ---
        function calculatePolylineProperties() { let totalLength = 0; let weightedCentroidSum = new THREE.Vector3(0, 0, 0); segmentsData.forEach(seg => { if (seg.length > 0) { totalLength += seg.length; weightedCentroidSum.addScaledVector(seg.centroid, seg.length); } }); const polylineCentroid = totalLength > 0 ? weightedCentroidSum.divideScalar(totalLength) : new THREE.Vector3(0, 0, 0); return { totalLength, polylineCentroid }; }
        function getDistanceToAxis(point, axis) { switch (axis) { case 'x': return Math.sqrt(point.y * point.y + point.z * point.z); case 'y': return Math.sqrt(point.x * point.x + point.z * point.z); case 'z': return Math.sqrt(point.x * point.x + point.y * point.y); default: return 0; } }
        function calculatePappusValues(totalLength, polylineCentroid, axis) { if (totalLength === 0) return { R: 0, d: 0, area: 0 }; const R = getDistanceToAxis(polylineCentroid, axis); const d = 2 * Math.PI * R; const area = totalLength * d; return { R, d, area }; }
        function updateRealTimeCalculations() { const angleRad = THREE.MathUtils.degToRad(revolutionAngle); const S_partial = currentTotalLength * currentCentroidDistanceR * angleRad; let R_calc = 0; const denominator = 2 * Math.PI * currentTotalLength; if (Math.abs(denominator) > EPSILON) { R_calc = S_partial / denominator; } partialSurfaceAreaSpan.textContent = S_partial.toFixed(3); calculatedDistanceRSpan.textContent = R_calc.toFixed(3); }

        // --- 3D Visualization ---
        function clearSurfaceMeshes() { surfaceMeshes.forEach(mesh => { scene.remove(mesh); if (mesh.geometry) mesh.geometry.dispose(); }); surfaceMeshes = []; }
        function clearCentroidPathVisual() { if (centroidPathVisual) { scene.remove(centroidPathVisual); if (centroidPathVisual.geometry) centroidPathVisual.geometry.dispose(); if (centroidPathVisual.material) centroidPathVisual.material.dispose(); centroidPathVisual = null; } }
        function clearSceneGeometry() { segmentLines.forEach(line => { scene.remove(line); if(line.geometry) line.geometry.dispose(); if(line.material) line.material.dispose(); }); segmentLines = []; clearSurfaceMeshes(); clearCentroidPathVisual(); }

        function drawSegments() {
            const lineMaterial = new THREE.LineBasicMaterial({ color: SEGMENT_COLOR, linewidth: 2 }); const arcMaterial = new THREE.LineBasicMaterial({ color: ARC_COLOR, linewidth: 2 });
            segmentsData.forEach(seg => { let line; if (seg.type === 'line') { const geometry = new THREE.BufferGeometry().setFromPoints([seg.p1, seg.p2]); line = new THREE.Line(geometry, lineMaterial); } else if (seg.type === 'arc' && seg.radius > EPSILON && seg.sweepAngle > EPSILON) { const arcPoints = []; const v1 = seg.p1.clone().sub(seg.center); const xAxis = v1.clone().normalize(); const yAxis = new THREE.Vector3().crossVectors(seg.normal, xAxis).normalize(); for (let i = 0; i <= ARC_SUBDIVISIONS; i++) { const angle = (i / ARC_SUBDIVISIONS) * seg.sweepAngle; const point = seg.center.clone().addScaledVector(xAxis, seg.radius * Math.cos(angle)).addScaledVector(yAxis, seg.radius * Math.sin(angle)); arcPoints.push(point); } const geometry = new THREE.BufferGeometry().setFromPoints(arcPoints); line = new THREE.Line(geometry, arcMaterial); } if (line) { scene.add(line); segmentLines.push(line); } });
        }

        function createAxisLabel(text, position, color) { const canvas = document.createElement('canvas'); const context = canvas.getContext('2d'); const fontSize = 48; context.font = `Bold ${fontSize}px Arial`; const metrics = context.measureText(text); const textWidth = metrics.width; canvas.width = textWidth + 20; canvas.height = fontSize + 10; context.font = `Bold ${fontSize}px Arial`; context.fillStyle = color; context.textAlign = 'center'; context.textBaseline = 'middle'; context.fillText(text, canvas.width / 2, canvas.height / 2); const texture = new THREE.CanvasTexture(canvas); texture.needsUpdate = true; const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false }); const sprite = new THREE.Sprite(material); const aspect = canvas.width / canvas.height; sprite.scale.set(AXIS_LABEL_SIZE * aspect * 0.5, AXIS_LABEL_SIZE * 0.5, 1); sprite.position.copy(position); sprite.renderOrder = 2; scene.add(sprite); return sprite; }
        function createAxisLabels() { axisLabels.forEach(label => scene.remove(label)); axisLabels = []; axisLabels.push(createAxisLabel('X', new THREE.Vector3(AXIS_LABEL_OFFSET, 0, 0), '#FF0000')); axisLabels.push(createAxisLabel('Y', new THREE.Vector3(0, AXIS_LABEL_OFFSET, 0), '#00CC00')); axisLabels.push(createAxisLabel('Z', new THREE.Vector3(0, 0, AXIS_LABEL_OFFSET), '#0000FF')); }

        function drawSurfaceOfRevolution_Manual_PerSegment() {
            clearSurfaceMeshes(); if (segmentsData.length === 0 || revolutionAngle <= 0 || !sharedSurfaceMaterial) return;
            const angleRad = THREE.MathUtils.degToRad(revolutionAngle); const rotationAxisVec = AXIS_VECTORS[axisOfRotation]; const numSteps = Math.max(1, Math.ceil(RADIAL_SEGMENTS * (revolutionAngle / 360))); const deltaAngle = angleRad / numSteps; const q = new THREE.Quaternion();
            segmentsData.forEach(seg => {
                const geometry = new THREE.BufferGeometry(); const vertices = []; const indices = []; let indexOffset = 0; const profilePoints = [];
                if (seg.type === 'line') { profilePoints.push(seg.p1.clone()); profilePoints.push(seg.p2.clone()); }
                else if (seg.type === 'arc' && seg.radius > EPSILON && seg.sweepAngle > EPSILON) { const v1 = seg.p1.clone().sub(seg.center); const xAxis = v1.clone().normalize(); const yAxis = new THREE.Vector3().crossVectors(seg.normal, xAxis).normalize(); for (let i = 0; i <= ARC_SUBDIVISIONS; i++) { const angle = (i / ARC_SUBDIVISIONS) * seg.sweepAngle; const point = seg.center.clone().addScaledVector(xAxis, seg.radius * Math.cos(angle)).addScaledVector(yAxis, seg.radius * Math.sin(angle)); profilePoints.push(point); } }
                if (profilePoints.length < 2) return;
                for (let i = 0; i < numSteps; i++) { const currentAngle = i * deltaAngle; const nextAngle = (i + 1) * deltaAngle; const pointsCurrent = profilePoints.map(p => p.clone().applyQuaternion(q.setFromAxisAngle(rotationAxisVec, currentAngle))); const pointsNext = profilePoints.map(p => p.clone().applyQuaternion(q.setFromAxisAngle(rotationAxisVec, nextAngle))); for (let j = 0; j < profilePoints.length - 1; j++) { const pA_curr = pointsCurrent[j]; const pB_curr = pointsCurrent[j + 1]; const pA_next = pointsNext[j]; const pB_next = pointsNext[j + 1]; vertices.push(pA_curr.x, pA_curr.y, pA_curr.z); vertices.push(pB_curr.x, pB_curr.y, pB_curr.z); vertices.push(pA_next.x, pA_next.y, pA_next.z); vertices.push(pB_next.x, pB_next.y, pB_next.z); indices.push(indexOffset + 0, indexOffset + 1, indexOffset + 2); indices.push(indexOffset + 1, indexOffset + 3, indexOffset + 2); indexOffset += 4; } }
                if (vertices.length === 0) return; geometry.setIndex(indices); geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); geometry.computeVertexNormals(); const segmentSurfaceMesh = new THREE.Mesh(geometry, sharedSurfaceMaterial); scene.add(segmentSurfaceMesh); surfaceMeshes.push(segmentSurfaceMesh); });
        }

        function drawCentroidPathVisual(centroid, axis) { clearCentroidPathVisual(); if (!centroid) return; const R = currentCentroidDistanceR; if (R < EPSILON) return; const points = []; const center = new THREE.Vector3(); let uAxis = new THREE.Vector3(); let vAxis = new THREE.Vector3(); switch (axis) { case 'x': center.set(centroid.x, 0, 0); uAxis.set(0, 1, 0); vAxis.set(0, 0, 1); break; case 'y': center.set(0, centroid.y, 0); uAxis.set(1, 0, 0); vAxis.set(0, 0, 1); break; case 'z': center.set(0, 0, centroid.z); uAxis.set(1, 0, 0); vAxis.set(0, 1, 0); break; } for (let i = 0; i <= CENTROID_PATH_SEGMENTS; i++) { const angle = (i / CENTROID_PATH_SEGMENTS) * Math.PI * 2; const point = new THREE.Vector3(); point.addScaledVector(uAxis, Math.cos(angle) * R); point.addScaledVector(vAxis, Math.sin(angle) * R); point.add(center); points.push(point); } const geometry = new THREE.BufferGeometry().setFromPoints(points); const material = new THREE.LineBasicMaterial({ color: CENTROID_PATH_COLOR, linewidth: 2 }); centroidPathVisual = new THREE.LineLoop(geometry, material); centroidPathVisual.renderOrder = 1; centroidPathVisual.visible = (revolutionAngle === 360); scene.add(centroidPathVisual); }

        // --- Update Cycle ---
        function updateVisualizationAndCalculations() {
            parseSegmentsFromUI(); const polylineProps = calculatePolylineProperties(); const pappusValues = calculatePappusValues(polylineProps.totalLength, polylineProps.polylineCentroid, axisOfRotation);
            currentTotalLength = polylineProps.totalLength; currentCentroidDistanceR = pappusValues.R;
            totalLengthSpan.textContent = currentTotalLength.toFixed(3); if (currentTotalLength > 0) { centroidCoordsSpan.textContent = `(${polylineProps.polylineCentroid.x.toFixed(2)}, ${polylineProps.polylineCentroid.y.toFixed(2)}, ${polylineProps.polylineCentroid.z.toFixed(2)})`; centroidDistanceRSpan.textContent = currentCentroidDistanceR.toFixed(3); centroidDistanceDSpan.textContent = pappusValues.d.toFixed(3); surfaceAreaSpan.textContent = pappusValues.area.toFixed(3); } else { centroidCoordsSpan.textContent = "N/A"; centroidDistanceRSpan.textContent = "0.000"; centroidDistanceDSpan.textContent = "0.000"; surfaceAreaSpan.textContent = "0.000"; }
            updateRealTimeCalculations();
            clearSceneGeometry(); drawSegments(); drawSurfaceOfRevolution_Manual_PerSegment(); if (currentTotalLength > 0) { drawCentroidPathVisual(polylineProps.polylineCentroid, axisOfRotation); }
        }

        // --- Animation Loop ---
        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }

        // --- Run ---
        init();

    </script>

</body>
</html>
