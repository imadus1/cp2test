<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pappus's Theorem - Realistic Surfaces</title>

    <style>
        /* CSS styles remain the same as the previous version */
        body { font-family: sans-serif; margin: 0; overflow: hidden; background-color: #f0f0f0; display: flex; }
        #container { display: flex; width: 100vw; height: 100vh; }
        #ui-controls { width: 380px; padding: 15px; background-color: #e9e9e9; overflow-y: auto; height: 100vh; box-sizing: border-box; display: flex; flex-direction: column; border-right: 1px solid #ccc; }
        #visualization-container { flex-grow: 1; height: 100vh; position: relative; }
        #visualizationCanvas { display: block; width: 100%; height: 100%; }
        h1, h2 { margin-top: 0; margin-bottom: 10px; border-bottom: 1px solid #ccc; padding-bottom: 5px; color: #333; }
        h1 { font-size: 1.4em; } h2 { font-size: 1.1em; }
        #segments-section, #settings-section, #calculations-section, #instructions { margin-bottom: 15px; padding: 12px; background-color: #fff; border: 1px solid #ddd; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        button { padding: 8px 15px; margin-bottom: 10px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; transition: background-color 0.2s ease; }
        button:hover { background-color: #0056b3; }
        .removeSegmentBtn { background-color: #dc3545; float: right; margin-left: 10px; padding: 4px 8px; font-size: 0.8em; }
        .removeSegmentBtn:hover { background-color: #c82333; }
        label { margin-right: 5px; display: inline-block; margin-bottom: 5px; }
        input[type="number"] { width: 60px; padding: 5px 4px; margin: 2px 3px 2px 0; border: 1px solid #ccc; border-radius: 3px; box-sizing: border-box; text-align: right; }
        input[type="range"] { width: 180px; vertical-align: middle; }
        #angleValue { display: inline-block; width: 35px; text-align: right; font-weight: bold; margin-left: 5px; }
        #calculations-section div { margin-bottom: 6px; font-size: 0.95em; line-height: 1.4; }
        #calculations-section span { font-weight: bold; color: #0056b3; background-color: #eef; padding: 1px 4px; border-radius: 3px; display: inline-block; min-width: 40px; text-align: right; }
        #centroidCoords { min-width: 150px; text-align: left; }
        .segment-input { margin-bottom: 15px; padding: 10px; border: 1px dashed #ccc; border-radius: 3px; background-color: #fdfdfd; }
        .point-input-group { display: flex; align-items: center; margin-bottom: 5px; }
        .point-input-group > span { font-weight: bold; margin-right: 8px; min-width: 25px; text-align: right; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; } input[type=number] { -moz-appearance: textfield; }
        hr { border: none; border-top: 1px solid #eee; margin: 15px 0; }
        #instructions { background-color: #f0f8ff; border-color: #cce5ff; }
        #instructions ul { padding-left: 20px; margin-top: 5px; margin-bottom: 5px; font-size: 0.9em; color: #333; }
        #instructions li { margin-bottom: 5px; }
        #instructions strong { color: #004085; }
        #settings-section > div { margin-bottom: 10px; }
        #settings-section > div > label:first-child { font-weight: bold; margin-right: 10px; min-width: 120px; display: inline-block; }
        #settings-section > div > label > input[type="radio"] { margin-right: 3px; vertical-align: middle; }
        #settings-section label[for="revolutionSlider"] { font-weight: bold; min-width: 120px; display: inline-block; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="container">
         <div id="ui-controls">
            <!-- UI sections -->
            <h1>Pappus's Theorem II</h1>
            <p>Surface Area = Total Length (L) × Centroid Path Distance (d)</p>
            <div id="segments-section"><h2>Segments</h2><button id="addSegmentBtn">Add Segment</button><div id="segmentsContainer"></div></div>
            <div id="settings-section"><h2>Settings</h2><div><label>Axis of Rotation:</label><label><input type="radio" name="axis" value="x"> X</label><label><input type="radio" name="axis" value="y" checked> Y</label><label><input type="radio" name="axis" value="z"> Z</label></div><div><label for="revolutionSlider">Revolution Angle:</label><input type="range" id="revolutionSlider" min="0" max="360" value="360" step="1"><span id="angleValue">360</span>°</div></div>
            <div id="calculations-section"><h2>Calculations (Full 360° Revolution)</h2><div>Total Length (L): <span id="totalLength">0.000</span></div><div>Polyline Centroid (C): <span id="centroidCoords">N/A</span></div><div>Dist. Centroid to Axis (R): <span id="centroidDistanceR">0.000</span></div><div>Dist. Traveled by C (d = 2πR): <span id="centroidDistanceD">0.000</span></div><div>Calculated Surface Area (L × d): <span id="surfaceArea">0.000</span></div></div>
            <div id="instructions"><p><strong>Instructions:</strong></p><ul><li>Use 'Add Segment' to define points. Each segment generates its own surface.</li><li>Remove segments using the 'Remove' button.</li><li>Use mouse (Left-drag: rotate, Right-drag: pan, Wheel: zoom) to view.</li><li>Select rotation axis (X, Y, or Z).</li><li>Adjust the slider to see partial revolution.</li><li>Calculations update automatically based on the full 360° revolution of the entire polyline.</li></ul></div>
        </div>
        <div id="visualization-container"><canvas id="visualizationCanvas"></canvas></div>
    </div>

    <!-- Segment Template (Same) -->
    <template id="segmentTemplate">
        <div class="segment-input">
            <button class="removeSegmentBtn">Remove</button>
            <div class="point-input-group">
                <span>P1:</span>
                <input type="number" class="coord p1x" value="0" step="0.1" placeholder="X" title="P1 X">
                <input type="number" class="coord p1y" value="0" step="0.1" placeholder="Y" title="P1 Y">
                <input type="number" class="coord p1z" value="0" step="0.1" placeholder="Z" title="P1 Z">
            </div>
             <div class="point-input-group">
                 <span>P2:</span>
                <input type="number" class="coord p2x" value="1" step="0.1" placeholder="X" title="P2 X">
                <input type="number" class="coord p2y" value="1" step="0.1" placeholder="Y" title="P2 Y">
                <input type="number" class="coord p2z" value="0" step="0.1" placeholder="Z" title="P2 Z">
            </div>
        </div>
    </template>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Global Variables --- (Same)
        let scene, camera, renderer, controls;
        let segmentsData = []; let segmentLines = []; let surfaceMeshes = [];
        let axisOfRotation = 'y'; let revolutionAngle = 360;
        let axisHelper, rotationAxisLine, centroidPathVisual; let axisLabels = [];
        let sharedSurfaceMaterial; // *** Variable to hold the shared material ***

        // --- Constants --- (Same)
        const SEGMENT_COLOR = 0x0000ff; const SURFACE_COLOR = 0xffa500; const AXIS_COLOR = 0xff0000; const CENTROID_PATH_COLOR = 0x00ff00;
        const RADIAL_SEGMENTS = 32; const CENTROID_PATH_SEGMENTS = 64;
        const AXIS_LABEL_OFFSET = 6.0; const AXIS_LABEL_SIZE = 1.5;

        // --- DOM Elements --- (Same)
        const segmentsContainer = document.getElementById('segmentsContainer'); const addSegmentBtn = document.getElementById('addSegmentBtn'); const segmentTemplate = document.getElementById('segmentTemplate'); const revolutionSlider = document.getElementById('revolutionSlider'); const angleValueSpan = document.getElementById('angleValue'); const axisRadios = document.querySelectorAll('input[name="axis"]'); const totalLengthSpan = document.getElementById('totalLength'); const centroidCoordsSpan = document.getElementById('centroidCoords'); const centroidDistanceRSpan = document.getElementById('centroidDistanceR'); const centroidDistanceDSpan = document.getElementById('centroidDistanceD'); const surfaceAreaSpan = document.getElementById('surfaceArea');

        // --- Rotation Axis Vectors --- (Same)
        const AXIS_VECTORS = { x: new THREE.Vector3(1, 0, 0), y: new THREE.Vector3(0, 1, 0), z: new THREE.Vector3(0, 0, 1) };

        // --- Initialization ---
        function init() {
            // Scene, Camera, Renderer, Lights, Controls setup (same basic setup)
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xcccccc); // Slightly darker background might show reflections better

            const vizContainer = document.getElementById('visualization-container');
            camera = new THREE.PerspectiveCamera(60, vizContainer.clientWidth / vizContainer.clientHeight, 0.1, 1000);
            camera.position.set(6, 6, 12); camera.lookAt(0, 0, 0);
            const canvas = document.getElementById('visualizationCanvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Use tone mapping for better HDR handling if using HDR env maps
            renderer.toneMappingExposure = 1.0;
            resizeRenderer();
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // Lower ambient if env map provides light
            scene.add(ambientLight);
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8); // Keep directional lights for highlights
            directionalLight1.position.set(5, 10, 7.5); scene.add(directionalLight1);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-5, -5, -5); scene.add(directionalLight2);
            controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.minDistance = 1; controls.maxDistance = 100; controls.maxPolarAngle = Math.PI;

            // *** Load Environment Map ***
            const loader = new THREE.CubeTextureLoader();
            // !!! REPLACE THESE PATHS with your actual cube map image paths !!!
            // Example using generic placeholders. Get images from Poly Haven (e.g., 'dikhololo_night_1k') or other sources.
            // Order: +X (px), -X (nx), +Y (py), -Y (ny), +Z (pz), -Z (nz)
            const textureCube = loader.setPath('./textures/cube/bridge2/').load( [ // Assumes a 'textures/cube/bridge2/' folder exists relative to the HTML
                'posx.jpg', 'negx.jpg',
                'posy.jpg', 'negy.jpg',
                'posz.jpg', 'negz.jpg'
            ], () => {
                console.log("Environment map loaded.");
                // Optional: Re-render once after texture loads if needed, though scene.environment update handles it.
                // updateVisualizationAndCalculations();
            }, undefined, (error) => {
                 console.error("Error loading environment map:", error);
                 // Provide fallback or notification
                 alert("Could not load environment map textures. Reflections may not appear correctly. Check texture paths and ensure images exist.");
            });
            scene.environment = textureCube; // Set scene environment for PBR lighting/reflections


            // *** Create Shared Surface Material ***
            sharedSurfaceMaterial = new THREE.MeshStandardMaterial({
                color: SURFACE_COLOR,
                transparent: true,
                opacity: 0.65,         // Adjust opacity (0.0 to 1.0)
                side: THREE.DoubleSide,
                metalness: 0.2,         // Low metalness for non-metal look (0.0 to 1.0)
                roughness: 0.3,         // Lower roughness for sharper reflections (0.0 to 1.0)
                envMapIntensity: 1.0,   // Intensity of environment map reflection
                refractionRatio: 0.95, // Simulate slight light bending (0.0 to 1.0) - subtle effect
                // depthWrite: false // Sometimes needed for complex transparency sorting, test if issues arise
            });


            // Helpers & Labels
            axisHelper = new THREE.AxesHelper(5); scene.add(axisHelper); createAxisLabels(); createRotationAxisLine();

            // Event Listeners (same)
            addSegmentBtn.addEventListener('click', addSegmentUI); segmentsContainer.addEventListener('input', handleSegmentInputChange); segmentsContainer.addEventListener('click', handleRemoveSegmentClick); revolutionSlider.addEventListener('input', handleRevolutionSlider); axisRadios.forEach(radio => radio.addEventListener('change', handleAxisChange)); window.addEventListener('resize', resizeRenderer);

            // Initial Setup
            addSegmentUI(); const firstSegInputs = segmentsContainer.querySelector('.segment-input'); if (firstSegInputs) { firstSegInputs.querySelector('.p1x').value = 0.5; firstSegInputs.querySelector('.p1y').value = 1; firstSegInputs.querySelector('.p2x').value = 1.5; firstSegInputs.querySelector('.p2y').value = 2; firstSegInputs.querySelector('.p2z').value = 0.5; } updateVisualizationAndCalculations(); animate();
        }

        function resizeRenderer() { /* ... same ... */ const vizContainer = document.getElementById('visualization-container'); const width = vizContainer.clientWidth; const height = vizContainer.clientHeight; if (width === 0 || height === 0) return; renderer.setSize(width, height); camera.aspect = width / height; camera.updateProjectionMatrix(); }

        // --- UI Management --- (Same)
        function addSegmentUI() { const templateContent = segmentTemplate.content.cloneNode(true); segmentsContainer.appendChild(templateContent); updateVisualizationAndCalculations(); }
        function handleSegmentInputChange(event) { if (event.target.classList.contains('coord')) { updateVisualizationAndCalculations(); } }
        function handleRemoveSegmentClick(event) { if (event.target.classList.contains('removeSegmentBtn')) { event.target.closest('.segment-input').remove(); updateVisualizationAndCalculations(); } }
        function handleRevolutionSlider(event) { revolutionAngle = parseFloat(event.target.value); angleValueSpan.textContent = revolutionAngle; clearSurfaceMeshes(); drawSurfaceOfRevolution_Manual_PerSegment(); if (centroidPathVisual) { centroidPathVisual.visible = (revolutionAngle === 360); } }
        function handleAxisChange(event) { axisOfRotation = event.target.value; updateVisualizationAndCalculations(); }

        // --- Data Parsing --- (Same)
        function parseSegmentsFromUI() { /* ... same ... */ segmentsData = []; const segmentDivs = segmentsContainer.querySelectorAll('.segment-input'); segmentDivs.forEach(div => { const p1 = new THREE.Vector3( parseFloat(div.querySelector('.p1x').value) || 0, parseFloat(div.querySelector('.p1y').value) || 0, parseFloat(div.querySelector('.p1z').value) || 0 ); const p2 = new THREE.Vector3( parseFloat(div.querySelector('.p2x').value) || 0, parseFloat(div.querySelector('.p2y').value) || 0, parseFloat(div.querySelector('.p2z').value) || 0 ); if (p1.distanceTo(p2) > 1e-6) { const length = p1.distanceTo(p2); const centroid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5); segmentsData.push({ p1, p2, length, centroid }); } }); }

        // --- Calculations --- (Same)
        function calculatePolylineProperties() { /* ... same ... */ let totalLength = 0; let weightedCentroidSum = new THREE.Vector3(0, 0, 0); segmentsData.forEach(seg => { totalLength += seg.length; weightedCentroidSum.addScaledVector(seg.centroid, seg.length); }); const polylineCentroid = totalLength > 0 ? weightedCentroidSum.divideScalar(totalLength) : new THREE.Vector3(0, 0, 0); return { totalLength, polylineCentroid }; }
        function getDistanceToAxis(point, axis) { /* ... same ... */ switch (axis) { case 'x': return Math.sqrt(point.y * point.y + point.z * point.z); case 'y': return Math.sqrt(point.x * point.x + point.z * point.z); case 'z': return Math.sqrt(point.x * point.x + point.y * point.y); default: return 0; } }
        function calculatePappusValues(totalLength, polylineCentroid, axis) { /* ... same ... */ if (totalLength === 0) return { R: 0, d: 0, area: 0 }; const R = getDistanceToAxis(polylineCentroid, axis); const d = 2 * Math.PI * R; const area = totalLength * d; return { R, d, area }; }


        // --- 3D Visualization ---

        function clearSurfaceMeshes() {
            surfaceMeshes.forEach(mesh => {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                // Don't dispose the shared material here!
            });
            surfaceMeshes = [];
        }

        function clearCentroidPathVisual() { /* ... same ... */ if (centroidPathVisual) { scene.remove(centroidPathVisual); if (centroidPathVisual.geometry) centroidPathVisual.geometry.dispose(); if (centroidPathVisual.material) centroidPathVisual.material.dispose(); centroidPathVisual = null; } }

        function clearSceneGeometry() { /* ... same ... */ segmentLines.forEach(line => { scene.remove(line); if(line.geometry) line.geometry.dispose(); if(line.material) line.material.dispose(); }); segmentLines = []; clearSurfaceMeshes(); if (rotationAxisLine) { scene.remove(rotationAxisLine); if(rotationAxisLine.geometry) rotationAxisLine.geometry.dispose(); if(rotationAxisLine.material) rotationAxisLine.material.dispose(); } rotationAxisLine = null; clearCentroidPathVisual(); }
        function drawSegments() { /* ... same ... */ const material = new THREE.LineBasicMaterial({ color: SEGMENT_COLOR, linewidth: 2 }); segmentsData.forEach(seg => { const points = [seg.p1, seg.p2]; const geometry = new THREE.BufferGeometry().setFromPoints(points); const line = new THREE.Line(geometry, material); scene.add(line); segmentLines.push(line); }); }
        function createRotationAxisLine() { /* ... same ... */ if (rotationAxisLine) scene.remove(rotationAxisLine); const material = new THREE.LineBasicMaterial({ color: AXIS_COLOR, linewidth: 2 }); let points = []; const length = 1000; switch (axisOfRotation) { case 'x': points = [new THREE.Vector3(-length, 0, 0), new THREE.Vector3(length, 0, 0)]; break; case 'y': points = [new THREE.Vector3(0, -length, 0), new THREE.Vector3(0, length, 0)]; break; case 'z': points = [new THREE.Vector3(0, 0, -length), new THREE.Vector3(0, 0, length)]; break; } const geometry = new THREE.BufferGeometry().setFromPoints(points); rotationAxisLine = new THREE.Line(geometry, material); rotationAxisLine.renderOrder = 1; scene.add(rotationAxisLine); }
        function createAxisLabel(text, position, color) { /* ... same ... */ const canvas = document.createElement('canvas'); const context = canvas.getContext('2d'); const fontSize = 48; context.font = `Bold ${fontSize}px Arial`; const metrics = context.measureText(text); const textWidth = metrics.width; canvas.width = textWidth + 20; canvas.height = fontSize + 10; context.font = `Bold ${fontSize}px Arial`; context.fillStyle = color; context.textAlign = 'center'; context.textBaseline = 'middle'; context.fillText(text, canvas.width / 2, canvas.height / 2); const texture = new THREE.CanvasTexture(canvas); texture.needsUpdate = true; const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false }); const sprite = new THREE.Sprite(material); const aspect = canvas.width / canvas.height; sprite.scale.set(AXIS_LABEL_SIZE * aspect * 0.5, AXIS_LABEL_SIZE * 0.5, 1); sprite.position.copy(position); sprite.renderOrder = 2; scene.add(sprite); return sprite; }
        function createAxisLabels() { /* ... same ... */ axisLabels.forEach(label => scene.remove(label)); axisLabels = []; axisLabels.push(createAxisLabel('X', new THREE.Vector3(AXIS_LABEL_OFFSET, 0, 0), '#FF0000')); axisLabels.push(createAxisLabel('Y', new THREE.Vector3(0, AXIS_LABEL_OFFSET, 0), '#00CC00')); axisLabels.push(createAxisLabel('Z', new THREE.Vector3(0, 0, AXIS_LABEL_OFFSET), '#0000FF')); }


        // *** Use the SHARED MATERIAL when creating meshes ***
        function drawSurfaceOfRevolution_Manual_PerSegment() {
            clearSurfaceMeshes();
            if (segmentsData.length === 0 || revolutionAngle <= 0 || !sharedSurfaceMaterial) return; // Check if material exists

            const angleRad = THREE.MathUtils.degToRad(revolutionAngle);
            const rotationAxis = AXIS_VECTORS[axisOfRotation];
            const numSteps = Math.max(1, Math.ceil(RADIAL_SEGMENTS * (revolutionAngle / 360)));
            const deltaAngle = angleRad / numSteps;
            const q = new THREE.Quaternion();

            segmentsData.forEach(seg => {
                const geometry = new THREE.BufferGeometry();
                const vertices = []; const indices = []; let indexOffset = 0;
                const p1_base = seg.p1.clone(); const p2_base = seg.p2.clone();

                for (let i = 0; i < numSteps; i++) {
                    const currentAngle = i * deltaAngle; const nextAngle = (i + 1) * deltaAngle;
                    const p1_curr = p1_base.clone().applyQuaternion(q.setFromAxisAngle(rotationAxis, currentAngle));
                    const p2_curr = p2_base.clone().applyQuaternion(q.setFromAxisAngle(rotationAxis, currentAngle));
                    const p1_next = p1_base.clone().applyQuaternion(q.setFromAxisAngle(rotationAxis, nextAngle));
                    const p2_next = p2_base.clone().applyQuaternion(q.setFromAxisAngle(rotationAxis, nextAngle));
                    vertices.push(p1_curr.x, p1_curr.y, p1_curr.z); vertices.push(p2_curr.x, p2_curr.y, p2_curr.z); vertices.push(p1_next.x, p1_next.y, p1_next.z); vertices.push(p2_next.x, p2_next.y, p2_next.z);
                    indices.push(indexOffset + 0, indexOffset + 1, indexOffset + 2); indices.push(indexOffset + 1, indexOffset + 3, indexOffset + 2);
                    indexOffset += 4;
                }
                if (vertices.length === 0) return;
                geometry.setIndex(indices);
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.computeVertexNormals(); // Crucial for lighting

                // *** Use the pre-defined sharedSurfaceMaterial ***
                const segmentSurfaceMesh = new THREE.Mesh(geometry, sharedSurfaceMaterial);
                scene.add(segmentSurfaceMesh);
                surfaceMeshes.push(segmentSurfaceMesh);
            });
        }


        // Centroid Path Visual (LineLoop - same as previous)
        function drawCentroidPathVisual(centroid, axis) { /* ... same ... */ clearCentroidPathVisual(); if (!centroid) return; const R = getDistanceToAxis(centroid, axis); if (R < 1e-6) return; const points = []; const center = new THREE.Vector3(); let uAxis = new THREE.Vector3(); let vAxis = new THREE.Vector3(); switch (axis) { case 'x': center.set(centroid.x, 0, 0); uAxis.set(0, 1, 0); vAxis.set(0, 0, 1); break; case 'y': center.set(0, centroid.y, 0); uAxis.set(1, 0, 0); vAxis.set(0, 0, 1); break; case 'z': center.set(0, 0, centroid.z); uAxis.set(1, 0, 0); vAxis.set(0, 1, 0); break; } for (let i = 0; i <= CENTROID_PATH_SEGMENTS; i++) { const angle = (i / CENTROID_PATH_SEGMENTS) * Math.PI * 2; const point = new THREE.Vector3(); point.addScaledVector(uAxis, Math.cos(angle) * R); point.addScaledVector(vAxis, Math.sin(angle) * R); point.add(center); points.push(point); } const geometry = new THREE.BufferGeometry().setFromPoints(points); const material = new THREE.LineBasicMaterial({ color: CENTROID_PATH_COLOR, linewidth: 2 }); centroidPathVisual = new THREE.LineLoop(geometry, material); centroidPathVisual.renderOrder = 1; centroidPathVisual.visible = (revolutionAngle === 360); scene.add(centroidPathVisual); }


        // --- Update Cycle --- (Same)
        function updateVisualizationAndCalculations() { parseSegmentsFromUI(); const polylineProps = calculatePolylineProperties(); const pappusValues = calculatePappusValues(polylineProps.totalLength, polylineProps.polylineCentroid, axisOfRotation); totalLengthSpan.textContent = polylineProps.totalLength.toFixed(3); if (polylineProps.totalLength > 0) { centroidCoordsSpan.textContent = `(${polylineProps.polylineCentroid.x.toFixed(2)}, ${polylineProps.polylineCentroid.y.toFixed(2)}, ${polylineProps.polylineCentroid.z.toFixed(2)})`; centroidDistanceRSpan.textContent = pappusValues.R.toFixed(3); centroidDistanceDSpan.textContent = pappusValues.d.toFixed(3); surfaceAreaSpan.textContent = pappusValues.area.toFixed(3); } else { centroidCoordsSpan.textContent = "N/A"; centroidDistanceRSpan.textContent = "0.000"; centroidDistanceDSpan.textContent = "0.000"; surfaceAreaSpan.textContent = "0.000"; } clearSceneGeometry(); createRotationAxisLine(); drawSegments(); drawSurfaceOfRevolution_Manual_PerSegment(); if (polylineProps.totalLength > 0) { drawCentroidPathVisual(polylineProps.polylineCentroid, axisOfRotation); } }

        // --- Animation Loop --- (Same)
        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }

        // --- Run --- (Same)
        init();

    </script>

</body>
</html>
